# -*- coding: utf-8 -*-

"""T2CharString operator specializer and generalizer.

PostScript glyph drawing operations can be expressed in multiple different
ways. For example, as well as the ``lineto`` operator, there is also a
``hlineto`` operator which draws a horizontal line, removing the need to
specify a ``dx`` coordinate, and a ``vlineto`` operator which draws a
vertical line, removing the need to specify a ``dy`` coordinate. As well
as decompiling :class:`fontTools.misc.psCharStrings.T2CharString` objects
into lists of operations, this module allows for conversion between general
and specific forms of the operation.

"""

from fontTools.cffLib import maxStackLimit


def stringToProgram(string):
	if isinstance(string, str):
		string = string.split()
	program = []
	for token in string:
		try:
			token = int(token)
		except ValueError:
			try:
				token = float(token)
			except ValueError:
				pass
		program.append(token)
	return program


def programToString(program):
	return ' '.join(str(x) for x in program)


def programToCommands(program, getNumRegions=None):
	"""Takes a T2CharString program list and returns list of commands.
	Each command is a two-tuple of commandname,arg-list.  The commandname might
	be empty string if no commandname shall be emitted (used for glyph width,
	hintmask/cntrmask argument, as well as stray arguments at the end of the
	program (¯\_(ツ)_/¯).
	'getNumRegions' may be None, or a callable object. It must return the
	number of regions. 'getNumRegions' takes a single argument, vsindex. If
	the vsindex argument is None, getNumRegions returns the default number
	of regions for the charstring, else it returns the numRegions for
	the vsindex.
	The Charstring may or may not start with a width value. If the first
	non-blend operator has an odd number of arguments, then the first argument is
	a width, and is popped off. This is complicated with blend operators, as
	there may be more than one before the first hint or moveto operator, and each
	one reduces several arguments to just one list argument. We have to sum the
	number of arguments that are not part of the blend arguments, and all the
	'numBlends' values. We could instead have said that by definition, if there
	is a blend operator, there is no width value, since CFF2 Charstrings don't
	have width values. I discussed this with Behdad, and we are allowing for an
	initial width value in this case because developers may assemble a CFF2
	charstring from CFF Charstrings, which could have width values.
	"""

	seenWidthOp = False
	vsIndex = None
	lenBlendStack = 0
	lastBlendIndex = 0
	commands = []
	stack = []
	it = iter(program)

	for token in it:
		if not isinstance(token, str):
			stack.append(token)
			continue

		if token == 'blend':
			assert getNumRegions is not None
			numSourceFonts = 1 + getNumRegions(vsIndex)
			# replace the blend op args on the stack with a single list
			# containing all the blend op args.
			numBlends = stack[-1]
			numBlendArgs = numBlends * numSourceFonts + 1
			# replace first blend op by a list of the blend ops.
			stack[-numBlendArgs:] = [stack[-numBlendArgs:]]
			lenBlendStack += numBlends + len(stack) - 1
			lastBlendIndex = len(stack)
			# if a blend op exists, this is or will be a CFF2 charstring.
			continue

		elif token == 'vsindex':
			vsIndex = stack[-1]
			assert type(vsIndex) is int

		elif (not seenWidthOp) and token in {'hstem', 'hstemhm', 'vstem', 'vstemhm',
			'cntrmask', 'hintmask',
			'hmoveto', 'vmoveto', 'rmoveto',
			'endchar'}:
			seenWidthOp = True
			parity = token in {'hmoveto', 'vmoveto'}
			if lenBlendStack:
				# lenBlendStack has the number of args represented by the last blend
				# arg and all the preceding args. We need to now add the number of
				# args following the last blend arg.
				numArgs = lenBlendStack + len(stack[lastBlendIndex:])
			else:
				numArgs = len(stack)
			if numArgs and (numArgs % 2) ^ parity:
				width = stack.pop(0)
				commands.append(('', [width]))

		if token in {'hintmask', 'cntrmask'}:
			if stack:
				commands.append(('', stack))
			commands.append((token, []))
			commands.append(('', [next(it)]))
		else:
			commands.append((token, stack))
		stack = []
	if stack:
		commands.append(('', stack))
	return commands


def _flattenBlendArgs(args):
	token_list = []
	for arg in args:
		if isinstance(arg, list):
			token_list.extend(arg)
			token_list.append('blend')
		else:
			token_list.append(arg)
	return token_list

def commandsToProgram(commands):
	"""Takes a commands list as returned by programToCommands() and converts
	it back to a T2CharString program list."""
	program = []
	for op,args in commands:
		if any(isinstance(arg, list) for arg in args):
			args = _flattenBlendArgs(args)
		program.extend(args)
		if op:
			program.append(op)
	return program


def _everyN(el, n):
	"""Group the list el into groups of size n"""
	if len(el) % n != 0: raise ValueError(el)
	for i in range(0, len(el), n):
		yield el[i:i+n]


class _GeneralizerDecombinerCommandsMap(object):

	@staticmethod
	def rmoveto(args):
		if len(args) != 2: raise ValueError(args)
		yield ('rmoveto', args)
	@staticmethod
	def hmoveto(args):
		if len(args) != 1: raise ValueError(args)
		yield ('rmoveto', [args[0], 0])
	@staticmethod
	def vmoveto(args):
		if len(args) != 1: raise ValueError(args)
		yield ('rmoveto', [0, args[0]])

	@staticmethod
	def rlineto(args):
		if not args: raise ValueError(args)
		for args in _everyN(args, 2):
			yield ('rlineto', args)
	@staticmethod
	def hlineto(args):
		if not args: raise ValueError(args)
		it = iter(args)
		try:
			while True:
				yield ('rlineto', [next(it), 0])
				yield ('rlineto', [0, next(it)])
		except StopIteration:
			pass
	@staticmethod
	def vlineto(args):
		if not args: raise ValueError(args)
		it = iter(args)
		try:
			while True:
				yield ('rlineto', [0, next(it)])
				yield ('rlineto', [next(it), 0])
		except StopIteration:
			pass
	@staticmethod
	def rrcurveto(args):
		if not args: raise ValueError(args)
		for args in _everyN(args, 6):
			yield ('rrcurveto', args)
	@staticmethod
	def hhcurveto(args):
		if len(args) < 4 or len(args) % 4 > 1: raise ValueError(args)
		if len(args) % 2 == 1:
			yield ('rrcurveto', [args[1], args[0], args[2], args[3], args[4], 0])
			args = args[5:]
		for args in _everyN(args, 4):
			yield ('rrcurveto', [args[0], 0, args[1], args[2], args[3], 0])
	@staticmethod
	def vvcurveto(args):
		if len(args) < 4 or len(args) % 4 > 1: raise ValueError(args)
		if len(args) % 2 == 1:
			yield ('rrcurveto', [args[0], args[1], args[2], args[3], 0, args[4]])
			args = args[5:]
		for args in _everyN(args, 4):
			yield ('rrcurveto', [0, args[0], args[1], args[2], 0, args[3]])
	@staticmethod
	def hvcurveto(args):
		if len(args) < 4 or len(args) % 8 not in {0,1,4,5}: raise ValueError(args)
		last_args = None
		if len(args) % 2 == 1:
			lastStraight = len(args) % 8 == 5
			args, last_args = args[:-5], args[-5:]
		it = _everyN(args, 4)
		try:
			while True:
				args = next(it)
				yield ('rrcurveto', [args[0], 0, args[1], args[2], 0, args[3]])
				args = next(it)
				yield ('rrcurveto', [0, args[0], args[1], args[2], args[3], 0])
		except StopIteration:
			pass
		if last_args:
			args = last_args
			if lastStraight